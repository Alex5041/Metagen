// also a vector class
class Point {
    x = 0
    y = 0

    fun plus(other) { return Point(x=x + other.x, y=y + other.y) }
    fun minus(other) { return Point(x=x - other.x, y=y - other.y) }
    fun crossProduct(other) { return x * other.y - y * other.x }
    fun scale(coeff) { return Point(x=x * coeff, y=y * coeff) }

    // angle in degrees // TODO invocation in function args
    fun rotate(angle, pivot=Point()) {
        s = toRadians(angle).sin()
        c = toRadians(angle).cos()
        this.x = this.x - pivot.x
        this.y = this.y - pivot.y

        xnew = this.x * c - this.y * s
        ynew = this.x * s + this.y * c
        this.x = pivot.x + xnew
        this.y = pivot.y + ynew
        return this
    }

    fun translate(vec) {
        this.x = this.x + vec.x
        this.y = this.y + vec.y
        return this
    }

    fun scale(coeff, origin) {
        this.x = this.x + (this.x - origin.x) * coeff
        this.y = this.y + (this.y - origin.y) * coeff
        return this
    }

    fun distance(p) {
        if(p is Point)
            return sqrt((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y))
    }

    fun toString() { return str(x) + " " + y}
}

object Constants {
    PI = 3.1415926539
}

fun toRadians(angle) {
    return double(angle) / 180 * Constants.PI
}

fun toDegrees(angle) {
    return double(angle) * Constants.PI / 180
}

class Segment {
    p1 = Point()
    p2 = Point()
    stroke = "#000000"
    strokeWidth = 1

    fun length() { return p1.distance(p2) }
    fun vec() { return p2.minus(p1) }
    fun isPerpendicular(other) { return dotProduct(other) == 0 }

    fun center() { return centerFromPointsList([p1, p2]) }
    fun rotate(angle, pivot=center()) {
        log(this)
        rotatePointsList([p1, p2], angle, pivot)
        return this
    }
    fun scale(coeff, origin=Point()) {
        scalePointsList([p1, p2], coeff, origin)
        return this
    }
    fun translate(vec) {
        translatePointsList([p1, p2], vec)
    }

    fun dotProduct(other) {
        vec = this.vec()
        otherVec = other.vec()
        return vec.x * otherVec.x + vec.y * otherVec.y
    }

    fun angleBetween(other) {
        if(other is Segment)
            return acos(cosAngleBetweenSegments(this, other))
        if(other is Line)
            return acos(cosAngleBetweenSegments(this, other.segment))
    }

    fun getLine() {
        return Line(a=p2.y-p1.y, b=p1.x-p2.x, c=p1.x*(p1.y-p2.y)+p1.y*(p2.x-p1.x))
    }

    fun inSegment(point) {
        line = getLine()
        if(!line.inLine(point))
            return false
        inX = if(point.x > p1.x) point.x <= p2.x else point.x > p2.x
        inY = if(point.y > p1.y) point.y <= p2.y else point.y > p2.y
        return inX && inY
    }

    svgArgs = {"name":"line", \
        "attributes": {"x1":p1.x, "y1":p1.y, \
        "x2":p2.x, "y2":p2.y,\
        "stroke":stroke,\
        "stroke-width":strokeWidth}}
}

class Line {
    // ax + by + c = 0
    a = 0
    b = 1
    c = 0

    fun inLine(point) {
        return a * point.x + b * point.y + c == 0
    }

    // get a base of the perpendicular from `point` to this line
    fun toLine(point) {
        perpendicular = getPerpendicularLineContainingPoint(point)
    }

    fun getPerpendicularLineContainingPoint(point) {
        aN = b
        bN = a
        cN = -(aN * point.x + bN * point.y)
        return Line(a=aN,b=bN,c=cN)
    }

    fun intersectsLine(line) {
        if(isCollinear(line)) {
            if(isSameLine(line))
                if(b == 0)
                    return [Point(x=-c/a, y=0), Point(x=-c/a, y=1)]
                else return [Point(x=0, y=-c/b), Point(x=1, y=(-c-a)/b)]
            else return 0
        }
        return Point(x=(b*other.c - c*other.b)/(a*other.b - b*other.a), \
            y=(c*other.a - a*other.c)/(a*other.b - b*other.a))
    }

    fun isSameLine(other) {
        if(isCollinear(other))
            return double(c) / a == double(other.c) / other.a
        return false
    }

    fun isCollinear(other) {
        if(b == 0 || other.b == 0) {
            if(b != other.b)
                return false
            return true
        }
        return double(a) / b == double(other.a) / other.b
    }
}
/* Base class for geometry with `points` property */
class ArrayGeom {
    svgName = "g"
    points = []
    fill = "#000000"
    stroke = "none"

    fun center() {return centerFromPointsList(points)}
    fun translate(vec) { translatePointsList() }

    fun rotate(angle, pivot=Point()) {
        rotatePointsList(points, angle, pivot)
    }

    fun scale(coeff, origin=Point()) {
        scalePointsList(list, coeff, origin)
    }

    svgArgs = {"name":svgName, "attributes":\
        {"points":points.joinToString(", "),\
        "stroke":stroke,"fill":fill}}
}

/* Polygon and polyline */
class Polyline: ArrayGeom {
    svgName = "polygon"
    points = []
    isClosed = false
}

class RegularPolygon: ArrayGeom {
    r = 35
    q = 4 // >= 3
    svgName = "polygon"
    convex = true // works for odd q
    center = Point(x=0, y=0)
    points = createPolygon()

    fun createPolygon() {
        res = []
        angle = 360 / q
        cur = 0
        foreach(i in range(1, q)) {
            p = Point(x = center.x + r, y = center.y)
            res.add(p.rotate(cur, center))
            cur = cur + (if(convex) angle else 2 * angle)
        }
        return res
    }
}
/* Similar to <g> tag in svg. */
class Plane {
    objects = []

    fun center() {
        points = []
        i = 0
    }

    fun rotate(angle, pivot = center()) {
        foreach(i in objects) { rotateFigure(i, angle, pivot) }
    }
}

/*
    Classes below can be rotated with svg.transform only
*/
class PointGeom {
    center = Point()
    fill = "#000000"
    stroke = "none"
    fun rotate(angle, pivot=Point()) {} // does nothing
    fun translate(vec) { this.center.translate(vec) }
    fun scalePointGeom(coeff, origin=center) {
        this.center.scale(coeff, origin)
    }
}

class Rectangle: PointGeom {
    width = 1
    height = 1

    fun center() { return center }
    fun length() { return }
    fun scale(coeff, origin=center) {
        scalePointGeom(coeff, origin)
        this.width = this.width * coeff
        this.height = this.height * coeff
    }

    fun downLeft() {
        return Point(x=center.x-width/2,y=center.y+height/2)
    }
    fun upLeft() {
        return Point(x=center.x-width/2,y=center.y-height/2)
    }
    fun upRight() {
        return Point(x=center.x+width/2,y=center.y-height/2)
    }
    fun downRight() {
        return Point(x=center.x+width/2,y=center.y+height/2)
    }

    svgArgs = {"name":"rect", \
        "attributes":{"width":width, "height":height, \
        "x":center.x - width / 2,\
        "y":center.y - height / 2,\
        "stroke":stroke,"fill":fill}}
}

class Circle: PointGeom {
    r = 1

    fun scale(coeff, origin=center) {
        scale(coeff, origin)
        this.r = this.r * coeff
    }

    svgArgs = {"name":"circle", \
        "attributes":{"cx":center.x, "cy":center.y,\
        "r":r,\
        "stroke":stroke,"fill":fill}}
}

class Ellipse: PointGeom {
    width = 1
    height = 1
    fun scale(coeff, origin=center) {
        scalePointGeom(coeff, origin)
        this.width = this.width * coeff
        this.height = this.height * coeff
    }

    svgArgs = {"name":"ellipse", "attributes":\
        {"cx":center.x, "cy":center.y,\
        "rx":width, "ry":height,\
        "stroke":stroke,"fill":fill}}
}

fun insCircles(c1, c2) {

}

fun cosAngleBetweenSegments(a, b) {
    return double(a.dotProduct(b)) / a.length() / b.length()
}

fun rotatePointsList(list, angle, pivot=Point()) {
    foreach(point in list)
        point.rotate(angle, pivot)
}

fun translatePointsList(list, vec) {
    foreach(point in list)
        point.translate(vec)
}

fun scalePointsList(list, coeff, origin=Point()) {
    foreach(point in list)
        point.scale(origin, coeff)
}

fun scalePointsListFromLine(list, segment, coeff) {
    except("not implemented")
}

// get center mass of points
fun centerFromPointsList(list) {
    res = Point()
    i = 0
    while(i < list.size) {
        res.x = res.x + list[i].x
        res.y = res.y + list[i].y
        i = i + 1
    }
    res.x = double(res.x) / list.size
    res.y = double(res.y) / list.size
    return res
}
